(self.webpackChunkgordan404wiki=self.webpackChunkgordan404wiki||[]).push([[2871],{6447:(n,a,s)=>{"use strict";s.r(a),s.d(a,{data:()=>t});const t={key:"v-ff5a9acc",path:"/interview/vue.html",title:"前端面试指北",lang:"zh-CN",frontmatter:{sidebar:"auto"},excerpt:"",headers:[{level:2,title:"VUE相关面试题",slug:"vue相关面试题",children:[{level:3,title:"v-if 和 v-show 的区别",slug:"v-if-和-v-show-的区别",children:[]},{level:3,title:"computed和watch的区别",slug:"computed和watch的区别",children:[]},{level:3,title:"v-if 与 v-for 为什么不建议一起使用",slug:"v-if-与-v-for-为什么不建议一起使用",children:[]},{level:3,title:"v-for 为什么要加 key",slug:"v-for-为什么要加-key",children:[]}]}],filePathRelative:"interview/vue.md",git:{updatedTime:1628688732e3,contributors:[{name:"lishuaixingNewBee",email:"vae.china@foxmail.com",commits:1}]}}},9746:(n,a,s)=>{"use strict";s.r(a),s.d(a,{default:()=>l});var t=s(4057);const e=(0,t.Wm)("h1",{id:"前端面试指北",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#前端面试指北","aria-hidden":"true"},"#"),(0,t.Uk)(" 前端面试指北")],-1),p=(0,t.Wm)("h2",{id:"vue相关面试题",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#vue相关面试题","aria-hidden":"true"},"#"),(0,t.Uk)(" VUE相关面试题")],-1),o=(0,t.Uk)("强烈建议阅读"),c={href:"/vueAnalysis/introduction/",target:"_blank",rel:"noopener noreferrer"},u=(0,t.Uk)("Vue源码分析"),i=(0,t.uE)('<h3 id="v-if-和-v-show-的区别" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show-的区别" aria-hidden="true">#</a> v-if 和 v-show 的区别</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。</p><p>v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）</p></div><h3 id="computed和watch的区别" tabindex="-1"><a class="header-anchor" href="#computed和watch的区别" aria-hidden="true">#</a> computed和watch的区别</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><ol><li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容，它可以设置 <code>getter</code> 和 <code>setter</code>。</li><li>从使用场景上说，<code>computed</code>适用一个数据被多个数据影响，而<code>watch</code>适用一个数据影响多个数据；</li><li><code>computed</code> 是在<code>Dep.update()</code>，执行之后，数据更新之前,watch 是在set刚开始的时候添加回调用，可以监听数据变化情况</li><li><code>watch</code>监听引用类型需要设置<code>deep:true</code></li></ol></div><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token punctuation">{</span>\n    data<span class="token operator">:</span> <span class="token punctuation">{</span>\n      name<span class="token operator">:</span> <span class="token string">&#39;狗蛋&#39;</span>\n    <span class="token punctuation">}</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n      info<span class="token operator">:</span><span class="token punctuation">{</span>\n        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;调用了getter属性&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&#39;牛逼&#39;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;调用了settter属性&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;狗蛋Plus&#39;</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span>  \n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 第一次访问 `this.name` 的时候, 会调用相应的 get(),记录了依赖项 `name`</span>\n<span class="token number">1</span>、在 computed 初始化的过程中会创建一个 watcher 并设置lazy<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span>所以在初始化时会求值，在页面中调用 computed 时，开始求值，调用 watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法<span class="token punctuation">,</span>并将 dirty<span class="token operator">=</span><span class="token boolean">false</span>。\n<span class="token number">2</span>、当 computed依赖的属性发生改变时，会调用 watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，将dirty<span class="token operator">=</span><span class="token boolean">true</span>。\n<span class="token number">3</span>、当在页面中再次获取该属性时，会再次调用 如果dirty为 truewatcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法，否则返回原来计算的值。这就是computed 为什么具有缓存效果的原因。\n</code></pre></div><h3 id="v-if-与-v-for-为什么不建议一起使用" tabindex="-1"><a class="header-anchor" href="#v-if-与-v-for-为什么不建议一起使用" aria-hidden="true">#</a> v-if 与 v-for 为什么不建议一起使用</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>v-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for 优先级高于 v-if,这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果遇到需要同时使用时可以考虑写成计算属性的方式。</p></div><h3 id="v-for-为什么要加-key" tabindex="-1"><a class="header-anchor" href="#v-for-为什么要加-key" aria-hidden="true">#</a> v-for 为什么要加 key</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>key 是为 Vue 中 vnode 的唯一标记，当diff oldCh 和 newCh 四种比较方式没有匹配到，如果设置了key就会用key比较，如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是原地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p></div><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key\n  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> map\n<span class="token punctuation">}</span>\n</code></pre></div>',12),l={render:function(n,a){const s=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.j4)(t.HY,null,[e,p,(0,t.Wm)("p",null,[o,(0,t.Wm)("a",c,[u,(0,t.Wm)(s)])]),i],64)}}}}]);